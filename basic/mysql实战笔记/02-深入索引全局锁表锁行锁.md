[TOC]

# 深入索引全局锁表锁行锁

- `DML`: Data Manipulation Language(数据操纵语言) 增删改数据
- `DDL`: Data Definition Language(数据定义语言) 加字段等 修改表结构的操作

## 1. 索引

- 数据库的底层存储的核心是基于数据模型,从理论上分析这个数据库的适用场景,这个数据库.**用`N叉树`的原因是减少访问磁盘数据块,树中的“N”取决于数据块的大小。**
- 每一个索引在 InnoDB 里面对应一棵 B+ 树。
  - 主键索引的叶子节点存的是***整行数据***。在 InnoDB 里，**主键索引**也被称为**聚簇索引（clustered index）**。
  - 非主键索引的叶子节点内容是***主键的值***。在 InnoDB 里，**非主键索引**也被称为**二级索引（secondary index）**。
  - 基于主键索引和普通索引的查询有什么区别？
    - 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
    - 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为***回表***。
  - 索引 k 已经“覆盖了”我们的查询需求，我们称为***覆盖索引***,由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用***覆盖索引***是一个常用的性能优化手段
  - **最左前缀原则**,不只是索引的全部定义,只要满足最左前缀.
    - 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的.(当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了)
    - 考虑的原则就是空间.
  - 索引下推优化: 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

## 2. 全局锁,表锁,行锁

#### a. 全局锁

​	**全局锁**就是**对整个数据库实例加锁**,MySQL 提供了一个加全局读锁的方法，命令是 `Flush tables with read lock (FTWRL)`,整个库处于只读状态.

   **全局锁的典型使用场景**是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本

   **一致性读是好，但前提是引擎要支持这个隔离级别。**

​	**single-transaction 方法只适用于所有的表使用事务引擎的库。**

​	既然要全库只读，为什么不使用 set global readonly=true 的方式呢?

- 在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用.
- 在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。

#### b. 表级锁

> 一种是表锁: 表锁的语法是 lock tables … read/write。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象.
>
> 一种是元数据锁（meta data lock，MDL).: 
>
> - MDL 的作用是，保证读写的正确性,一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。
>
> - 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
> - 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

#### c. 行锁

> MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁.比如 MyISAM 引擎就不支持行锁。
>
> - 在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议
> - 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放.

