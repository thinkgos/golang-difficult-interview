# 容器基础

> - 容器本身没有价值,有价值的是“容器编排”
> - 容器的本质就是一个进程.
> - 容器是一个“单进程”模型.
> - Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：
>   - 启用 Linux Namespace 配置;
>   - 设置指定的 Cgroups 参数;
>   - 切换进程的根目录(Change Root).

- `Namespace`隔离
  - `Mount Namespace` 修改的,是容器进程对文件系统“挂载点”的认知.但是,这也就意味着,只有在“挂载”这个操作发生之后,进程的视图才会被改变.而在此之前,新创建的容器会直接继承宿主机的各个挂载点.
  - `Mount Namespace` 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变,一定是伴随着挂载操作（mount）才能生效.
  - `Mount Namespace` 正是基于对 `chroot` 的不断改良才被发明出来的,它也是 Linux 操作系统里的第一个 `Namespace`.
  - 为了能够让容器的这个根目录看起来更“真实”,我们一般会在这个容器的根目录下挂载一个完整操作系统的文件系统,而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统,就是所谓的“容器镜像”.它还有一个更为专业的名字,叫作：`rootfs(根文件系统)`.
- `Cgroups`是Linux 内核中用来为进程设置**资源限制**的一个重要功能.(包括cpu,内存,磁盘,网络带宽)
  - `Linux Cgroups` 的设计还是比较易用的,简单粗暴地理解呢,它就是一个子系统目录加上一组资源限制文件的组合.
- `rootfs `只是一个操作系统所包含的文件、配置和目录,并不包括操作系统内核.在 Linux 操作系统中,这两部分是分开存放的,操作系统只有在开机启动时才会加载指定版本的内核镜像. 容器技术使用了 `rootfs `机制和 `Mount Namespace`，构建出了一个同宿主机完全隔离开的文件系统环境。
  - Docker 项目在最后一步的切换上会优先使用 `pivot_root` 系统调用,如果系统不支持,才会使用` chroot`.
  - **同一台机器上的所有容器,都共享宿主机操作系统的内核.**这就意味着,如果你的应用程序需要配置内核参数、加载额外的内核模块,以及跟内核进行直接的交互,你就需要注意了:这些操作和依赖的对象,都是宿主机操作系统的内核,它对于该机器上的所有容器来说是一个“全局变量”,牵一发而动全身.
  - 由于 `rootfs` 的存在,容器才有了一个被反复宣传至今的重要特性:**一致性**
    - 由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。这种深入到操作系统级别的运行环境一致性，打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟
    - `rootfs`有三部份组成 ` /var/lib/docker/aufs/mnt`
      - 第一部份: 只读层,它最这个容器的`rootfs`最下面五层可读层
      - 第二部份: 可读写层,它是这个容器的 `rootfs` 最上面的一层 
      - 第三部份: init层,夹在只读层与读写层之间.Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 `/etc/hosts`、`/etc/resolv.conf`等信息,但是用户往往需要在启动容器时写入一些指定的值比如 `hostname`这些修改往往只对当前的容器有效，我们并不希望执行 docker commit 时，把这些信息连同可读写层一起提交掉



![](./asserts/k8s知识图谱.jpg)



![](./asserts/k8s全景图.png)